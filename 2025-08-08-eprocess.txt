╭─────────────────────────────────────────────────────╮
│ ✻ Welcome to Claude Code!                           │
│                                                     │
│   /help for help, /status for your current setup    │
│                                                     │
│   cwd: C:\Users\XiaM\Documents\GitHub\ark\examples  │
│                                                     │
│   ───────────────────────────────────────────────── │
│                                                     │
│   Overrides (via env):                              │
│                                                     │
│   • API timeout: 600000ms                           │
│   • API Base URL:                                   │
│   https://api.duckcode.top/api/claude               │
╰─────────────────────────────────────────────────────╯

> 我们拿到EPROCESS后如何获取进程路径？

● 在获取到EPROCESS结构后，可以通过以下几种方法获取进程路径：

  方法1：通过EPROCESS->SeAuditProcessCreationInfo

  NTSTATUS GetProcessImagePath(PEPROCESS Process, PUNICODE_STRING* ImagePath)
  {
      // 获取SeAuditProcessCreationInfo偏移
      size_t auditInfo_offset = ntos.GetOffset("_EPROCESS", "SeAuditProcessCreationInfo");

      // SeAuditProcessCreationInfo->ImageFileName->Name 包含完整路径
      PVOID auditInfo = *(PVOID*)((ULONG_PTR)Process + auditInfo_offset);
      if (auditInfo) {
          PUNICODE_STRING fullPath = (PUNICODE_STRING)((ULONG_PTR)auditInfo + 0x10);
          *ImagePath = fullPath;
          return STATUS_SUCCESS;
      }

      return STATUS_UNSUCCESSFUL;
  }

  方法2：通过EPROCESS->SectionObject->FileObject

  NTSTATUS GetProcessPathFromSection(PEPROCESS Process, PWCHAR PathBuffer, ULONG BufferSize)
  {
      // 获取SectionObject
      size_t sectionObject_offset = ntos.GetOffset("_EPROCESS", "SectionObject");
      PVOID sectionObject = *(PVOID*)((ULONG_PTR)Process + sectionObject_offset);

      if (sectionObject) {
          // Section->FileObject->FileName
          size_t fileObject_offset = ntos.GetOffset("_SECTION", "FileObject");
          PFILE_OBJECT fileObject = *(PFILE_OBJECT*)((ULONG_PTR)sectionObject + fileObject_offset);

          if (fileObject && fileObject->FileName.Buffer) {
              RtlStringCchCopyW(PathBuffer, BufferSize/sizeof(WCHAR),
                               fileObject->FileName.Buffer);
              return STATUS_SUCCESS;
          }
      }

      return STATUS_UNSUCCESSFUL;
  }

  方法3：使用ZwQueryInformationProcess API

  NTSTATUS GetProcessImageFileName(HANDLE ProcessId, PWCHAR PathBuffer, ULONG BufferSize)
  {
      HANDLE hProcess = NULL;
      NTSTATUS status;

      // 打开进程句柄
      OBJECT_ATTRIBUTES objAttr;
      InitializeObjectAttributes(&objAttr, NULL, 0, NULL, NULL);
      CLIENT_ID clientId = { ProcessId, NULL };

      status = ZwOpenProcess(&hProcess, PROCESS_QUERY_INFORMATION,
                            &objAttr, &clientId);
      if (!NT_SUCCESS(status)) {
          return status;
      }

      // 查询进程路径
      ULONG returnLength;
      status = ZwQueryInformationProcess(hProcess, ProcessImageFileName,
                                        PathBuffer, BufferSize, &returnLength);

      ZwClose(hProcess);
      return status;
  }

  方法4：通过PEB->ProcessParameters

  NTSTATUS GetProcessPathFromPEB(PEPROCESS Process, PWCHAR PathBuffer, ULONG BufferSize)
  {
      // 获取PEB地址
      size_t peb_offset = ntos.GetOffset("_EPROCESS", "Peb");
      PPEB peb = *(PPEB*)((ULONG_PTR)Process + peb_offset);

      if (peb) {
          __try {
              // 附加到目标进程地址空间
              KAPC_STATE apcState;
              KeStackAttachProcess(Process, &apcState);

              // 获取ProcessParameters
              if (peb->ProcessParameters) {
                  PRTL_USER_PROCESS_PARAMETERS params = peb->ProcessParameters;
                  if (params->ImagePathName.Buffer) {
                      RtlStringCchCopyW(PathBuffer, BufferSize/sizeof(WCHAR),
                                       params->ImagePathName.Buffer);
                  }
              }

              KeUnstackDetachProcess(&apcState);
              return STATUS_SUCCESS;
          } __except (EXCEPTION_EXECUTE_HANDLER) {
              KeUnstackDetachProcess(&apcState);
              return STATUS_UNSUCCESSFUL;
          }
      }

      return STATUS_UNSUCCESSFUL;
  }

  推荐方法选择

  - SeAuditProcessCreationInfo: 最简单可靠，直接在内核空间访问
  - SectionObject方式: 适合获取可执行文件映像路径
  - ZwQueryInformationProcess: 系统标准API，但需要进程句柄
  - PEB方式: 需要切换地址空间，但信息最完整

  建议在ARK项目中优先使用方法1，失败时回退到方法2作为备选方案。

