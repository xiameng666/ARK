键盘输入保护常常是在驱动层率先拦截Irp并解析出按键，通过通信发给R3应用。

## 早期Hook思路
1. 提前知道设备名->通过`IoGetDeviceObjectPointer(...)`得到文件对象和设备对象

![](https://cdn.nlark.com/yuque/0/2025/png/49487941/1753549836846-37791b75-2b01-40cd-b387-7eb7c4d3866e.png)

2. 设备对象得到驱动对象 

`pDrvObj = DeviceObject->DriverObject`

3. 保存旧的处理函数,卸载时恢复

`PDRIVER_DISPATCH orginDispatchRead = pDrvObj->MajorFunction[IRP_MJ_READ]`

4. 替换驱动对象的读请求处理函数为Hook实现函数

`pDrvObj->MajorFunction[IRP_MJ_READ] = FakeDispatchRead(...) `

5. 写`FakeDispatchRead(...)`实现功能

**内核Hook常规重入问题，引用计数尽可能规避卸载蓝屏**

```c
DriverUnload(){
    //检测引用计数都为0再卸载 
    //否则FakeDispatchRead代码段被清空还在执行
}

NTSTATUS FakeDispatchRead(
    _In_ struct _DEVICE_OBJECT* DeviceObject,
    _Inout_ struct _IRP* Irp) {
    InterlockedIncrement(&g_nRefCount);
    
    //干活 
    
    InterlockedDecrement(&g_nRefCount);
    //实际上减少引用计数到返回的执行过程仍可导致蓝屏
    return Status;
}
```



**早期驱动对象Hook的缺陷：异步导致漏数据**

键盘读取是异步的，IRP发起时数据尚未准备好

真正的数据填充发生在中断处理和完成例程中

```c
NTSTATUS FakeDispatchRead(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
    // 问题：此时SystemBuffer通常是空的！
    // 因为读取是异步操作，数据还没有准备好
    UCHAR* pBuffer = Irp->AssociatedIrp.SystemBuffer;
    
    // 这里打印的数据往往是空的或无效的
    DbgPrint("Buffer: %p\n", pBuffer);
    
    // 直接调用原始函数
    return originalDispatchRead(DeviceObject, Irp);
}
```



**键盘io是什么方式，如何解析拿到的irp  buffer**

使用DeviceTree查看，`KeyboardClasss0`的设备标志有`BUFFER_IO`,拿`Irp->AssociatedIrp.SystemBuffer`![](https://cdn.nlark.com/yuque/0/2025/png/49487941/1753535733197-62d5d64b-f7e0-4367-a1e5-5ab6b845c590.png)

```c
PIO_NTSTATUS FakeDispatchRead(...){
    STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG nLength = pIrpStack->Parameters.Read.Length;
    UCHAR* pBuffer = Irp->AssociatedIrp.SystemBuffer;
    for (ULONG i = 0; i < nLength; i++) {
            DbgPrint("%02X ", pBuffer[i]);
    }
}
```

`SystemBuffer`内是键盘扫描码，扫描码没有大小写区分，打印数据观察：

![](https://cdn.nlark.com/yuque/0/2025/png/49487941/1753536268303-3f63186b-5c7c-40f2-bd97-677b8d5009f2.png)

解析放在文末





## 驱动的模块化设计   
驱动也是模块化的 Irp从上往下访问驱动栈，每层的驱动可以选择处理请求或传递给下层。

Irp ->Keyboad.sys ->USB.sys->........  

使用`IoAttachDevice(...)`/`IoAttachDeviceByPointer(A,B)`指定A Attach到B的顶层。

此时A先收到Irp，可以选择：

+ `IoCompleteRequest(...)`完成请求
+ `IoCallDriver(<font style="color:rgb(22, 22, 22);background-color:rgb(240, 240, 240);">DeviceObject，Irp</font>)`将请求传递给B
+ `IoSetCompletinRoutine(...)` 为Irp设置一个类似回调函数,当Irp被完成后会执行回调 

```c
NTSTATUS IoSetCompletionRoutine(
    IN PIRP Irp,                    // 目标IRP
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,  // 完成例程函数
    IN PVOID Context,               // 传递给完成例程的上下文
    IN BOOLEAN InvokeOnSuccess,     // 成功时是否调用
    IN BOOLEAN InvokeOnError,       // 错误时是否调用
    IN BOOLEAN InvokeOnCancel       // 取消时是否调用
);
```

+ `IoSkipCurrentIrpStackLocation`下层驱动会直接使用当前层的堆栈位置
+ `<font style="color:rgb(22, 22, 22);">IoCopyCurrentIrpStackLocationToNext</font>`<font style="color:rgb(22, 22, 22);">将当前IRP堆栈拷贝到下一层。当我们在当前层调用</font>`<font style="color:rgb(22, 22, 22);">IoSetCompletinRoutine</font>`<font style="color:rgb(22, 22, 22);">设置了一个函数指针，使用它</font>可以保护这个函数指针

注意 必须选择Skip或Copy中的一种。

## 驱动过滤
一个驱动创建多个设备对象，1个用来拦截IRP，1个用来和R3通讯



1. 目标是拦截键盘的`DispatchRead`。在`DriverEnry`给设备对象的所有处理函数设置为`DispatchComn()` 后单独设置读

```c
for (int i = 0; i < IRP_MJ_MAXIMUM_FUNCTION + 1; i++) {
    DriverObject->MajorFunction[i] = DispatchComm;
}
DriverObject->MajorFunction[IRP_MJ_READ] = DispatchRead;//目标是读

AttachDevice(DriverObject);//封装一个函数
```

2. 在`AttachDevice()`中通过设备名称获取键盘的设备对象

```c
RtlInitUnicodeString(&ustrDevName, L"\\device\\KeyboardClass0");
Status = IoGetDeviceObjectPointer(&ustrDevName,
    FILE_ALL_ACCESS,
    &FileObject,
    &pTargetDevice);

if (!NT_SUCCESS(Status)) 
    return Status;
```

3. 在`AttachDevice()`中创建用于过滤驱动的设备

```c
DEVICE_OBJECT* pSourceDevice = NULL;
RtlInitUnicodeString(&ustrDevName, L"\\device\\KbclassFilter");
Status = IoCreateDevice(DriverObject,
    sizeof(DEV_EXT), 	 
    &ustrDevName,
    FILE_DEVICE_KEYBOARD,//必须和过滤的设备一致
    0,
    FALSE,
    &pSourceDevice);

//由于DriverEntry跑完代码就释放了，在DEV_EXT中存储需要的数据，后续提供设备对象拿
DEV_EXT *pDevExt = (DEV_EXT*)pSourceDevice->DeviceExtension;
RtlZeroMemory(pDevExt, sizeof(DEV_EXT));
pDevExt->pSourceDevice = pSourceDevice;
pDevExt->pTargetDevice = pTargetDevice;

//沿用目标设备属性 但是目标设备是初始化完的，需要补充DO_DEVICE_INITIALIZING
pSourceDevice->Flags = pTargetDevice->Flags | DO_DEVICE_INITIALIZING;

//实现 IRP->KbclassFilter->KeyboardClass0->...
if (IoAttachDeviceToDeviceStack(pSourceDevice, pTargetDevice) == NULL) {
    return STATUS_UNSUCCESSFUL;
}

return Status;
```

在`DriverEntry`创建设备对象的时候，操作系统会给设备对象设置`DO_DEVICE_INITIALIZING`标志，Irp一旦检测到这个标志就会挂起，避免驱动没有初始化完就要处理请求。当`DriverEntry`返回，IO管理器会自动清除该标志。

4. 实现`DispatchComm`。**我们不关心的Irp处理走这里，不做任何事交给下层驱动。**

```c
NTSTATUS DispatchComm(_In_ struct _DEVICE_OBJECT* DeviceObject,
    _Inout_ struct _IRP* Irp) {
    DEV_EXT* pDevExt = (DEV_EXT*)DeviceObject->DeviceExtension;
    
    //将当前IRP堆栈当做下层驱动IRP堆栈 、
    //如果当前层注册了CompletionRoutine，、
    //下层再次注册，会覆盖掉上层注册的CompletionRoutine函数指针
    IoSkipCurrentIrpStackLocation(Irp); 

    //IRP交给下一层驱动
    return IoCallDriver(pDevExt->pTargetDevice, Irp);
}
```

5. `Unload`中卸载设备

```c
VOID Unload(struct _DRIVER_OBJECT* DriverObject) {
    UNREFERENCED_PARAMETER(DriverObject);

    DEV_EXT* pDevExt = (DEV_EXT*)DriverObject->DeviceObject->DeviceExtension;
    IoDetachDevice(pDevExt->pTargetDevice);
    IoDeleteDevice(pDevExt->pSourceDevice);
}
```

6. 重点关注`DispatchRead`，这是我们需要拦截的处理

读请求是异步的。先发起读请求再按键盘，键盘按下会发起中断，将挂起的Irp唤醒处理。处理完当前Irp后立刻再发起一个读请求等待输入。就像windows的消息机制，是先调getmessage然后一直等待消息来。**如何知道读请求的数据读完了？注册完成例程**

```c
NTSTATUS DispatchRead(_In_ struct _DEVICE_OBJECT* DeviceObject,
    _Inout_ struct _IRP* Irp) {
    DEV_EXT* pDevExt = (DEV_EXT*)DeviceObject->DeviceExtension;

    //保护当前栈
    IoCopyCurrentIrpStackLocationToNext(Irp); 

    //注册完成例程  ReadCompletion函数
    IoSetCompletionRoutine(Irp, ReadCompletion, NULL, TRUE, TRUE, TRUE);

    //调用下一个层驱动
    return IoCallDriver(pDevExt->pTargetDevice, Irp);
}
```

执行`ReadCompletion`时,irql==2，分页内存用不了，操作的是SystemBuffer非分页内存。所以在这里别乱用API。可以用延迟工作线程干活

[系统工作线程 - Windows drivers](https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/system-worker-threads)[https://blog.csdn.net/qq726232111/article/details/111769499](https://blog.csdn.net/qq726232111/article/details/111769499)

```c
NTSTATUS ReadCompletion(
    __in PDEVICE_OBJECT  DeviceObject,
    __in PIRP  Irp,
    __in PVOID  Context)
{
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Context);

    //即使Irp请求被挂起了，也会调用ReadCompletion。
    //PendingReturned代表被挂起，需保持一致。
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //解析结构体
    KEYBOARD_INPUT_DATA* pInputData = (KEYBOARD_INPUT_DATA*)Irp->AssociatedIrp.SystemBuffer;
    for (int i = 0; i < Irp->IoStatus.Information / sizeof(KEYBOARD_INPUT_DATA); i++) {
        //pInputData[i].MakeCode是...解析它即可
    }
    return Irp->IoStatus.Status;//必须一致 否则死机
}
```







**引用计数问题**

LONG g_nRefCount = 0;

在Unload卸载代码前判断	  while (g_nRefCount != 0);

在ReadCompletion返回时 InterlockedDecrement(&g_nRefCount);

在DispatchRead入口	  InterlockedDecrement(&g_nRefCount); 

不推荐卸载 因为引用计数自减 到函数返回间 仍有执行Unload的时间差 概率蓝屏

用KEVENT可以完美避免蓝屏吗？



**解析KEYBOARD_INPUT_DATA与MakeCode**

将`SystemBuffer`数据按`KEYBOARD_INPUT_DATA`解析，并将`MakeCode`解释成按键。

```c
typedef struct _KEYBOARD_INPUT_DATA {
    USHORT UnitId;           // 键盘单元ID（多键盘系统中区分不同键盘）
    USHORT MakeCode;         // 扫描码（硬件按键标识）
    USHORT Flags;            // 标志位（按下/释放、扩展键等）
    USHORT Reserved;         // 保留字段（通常为0）
    ULONG ExtraInformation;  // 额外信息（时间戳、注入标记等）
} KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA;
```

[KEYBOARD_INPUT_DATA (ntddkbd.h) - Win32 apps](https://learn.microsoft.com/zh-cn/windows/win32/api/ntddkbd/ns-ntddkbd-keyboard_input_data?redirectedfrom=MSDN)

![](https://cdn.nlark.com/yuque/0/2025/png/49487941/1753551899366-7fb68e22-c372-43a9-bd01-d341dd00e14f.png)

所以我们解析`SystemBuffer`的时候结构体的数量不固定，很可能一下来两三个按键。

switch case 那就上AI！

```c
// 扫描码到字符的映射表
static CHAR g_ScanCodeToChar[0x60] = {
    0,    0,   '1', '2', '3', '4', '5', '6',  // 0x00-0x07
    '7', '8',  '9', '0', '-', '=',  0,   0,   // 0x08-0x0F (0x0E=Backspace, 0x0F=Tab)
    'q', 'w',  'e', 'r', 't', 'y', 'u', 'i', // 0x10-0x17
    'o', 'p',  '[', ']',  0,   0,  'a', 's', // 0x18-0x1F (0x1C=Enter, 0x1D=LCtrl)
    'd', 'f',  'g', 'h', 'j', 'k', 'l', ';', // 0x20-0x27
    '\'','`',   0, '\\', 'z', 'x', 'c', 'v', // 0x28-0x2F (0x2A=LShift)
    'b', 'n',  'm', ',', '.', '/',  0,  '*', // 0x30-0x37 (0x36=RShift, 0x37=NumPad*)
    0,   ' ',   0,   0,   0,   0,   0,   0,  // 0x38-0x3F (0x38=LAlt, 0x39=Space, 0x3A=CapsLock)
    0,   0,    0,   0,   0,   0,   0,   0,   // 0x40-0x47 (F1-F8...)
    0,   0,    0,   0,   0,   0,   0,   0,   // 0x48-0x4F
    0,   0,    0,   0,   0,   0,   0,   0,   // 0x50-0x57
    0,   0,    0,   0,   0,   0,   0,   0    // 0x58-0x5F
};

// 按键标志定义
#define KEY_MAKE        0x0000  // 按键按下
#define KEY_BREAK       0x0001  // 按键释放
#define KEY_E0          0x0002  // 扩展键前缀

// 扫描码转换为字符
CHAR ScanCodeToChar(USHORT scanCode) {
    if (scanCode < sizeof(g_ScanCodeToChar)) {
        return g_ScanCodeToChar[scanCode];
    }
    return 0; // 无效扫描码
}

// 获取特殊按键名称
VOID GetSpecialKeyName(USHORT scanCode, PCHAR keyName, SIZE_T maxLen) {
    switch (scanCode) {
        case 0x01: strncpy(keyName, "ESC", maxLen); break;
        case 0x0E: strncpy(keyName, "BACKSPACE", maxLen); break;
        case 0x0F: strncpy(keyName, "TAB", maxLen); break;
        case 0x1C: strncpy(keyName, "ENTER", maxLen); break;
        case 0x1D: strncpy(keyName, "LCTRL", maxLen); break;
        case 0x2A: strncpy(keyName, "LSHIFT", maxLen); break;
        case 0x36: strncpy(keyName, "RSHIFT", maxLen); break;
        case 0x38: strncpy(keyName, "LALT", maxLen); break;
        case 0x3A: strncpy(keyName, "CAPSLOCK", maxLen); break;
        case 0x3B: strncpy(keyName, "F1", maxLen); break;
        case 0x3C: strncpy(keyName, "F2", maxLen); break;
        case 0x3D: strncpy(keyName, "F3", maxLen); break;
        case 0x3E: strncpy(keyName, "F4", maxLen); break;
        case 0x3F: strncpy(keyName, "F5", maxLen); break;
        case 0x40: strncpy(keyName, "F6", maxLen); break;
        case 0x41: strncpy(keyName, "F7", maxLen); break;
        case 0x42: strncpy(keyName, "F8", maxLen); break;
        case 0x43: strncpy(keyName, "F9", maxLen); break;
        case 0x44: strncpy(keyName, "F10", maxLen); break;
        default: _snprintf(keyName, maxLen, "KEY_0x%02X", scanCode); break;
    }
}

// 处理扩展键
VOID ProcessExtendedKey(USHORT scanCode, PCHAR keyName, SIZE_T maxLen) {
    switch (scanCode) {
        case 0x1D: strncpy(keyName, "RCTRL", maxLen); break;
        case 0x38: strncpy(keyName, "RALT", maxLen); break;
        case 0x47: strncpy(keyName, "HOME", maxLen); break;
        case 0x48: strncpy(keyName, "UP", maxLen); break;
        case 0x49: strncpy(keyName, "PGUP", maxLen); break;
        case 0x4B: strncpy(keyName, "LEFT", maxLen); break;
        case 0x4D: strncpy(keyName, "RIGHT", maxLen); break;
        case 0x4F: strncpy(keyName, "END", maxLen); break;
        case 0x50: strncpy(keyName, "DOWN", maxLen); break;
        case 0x51: strncpy(keyName, "PGDN", maxLen); break;
        case 0x52: strncpy(keyName, "INSERT", maxLen); break;
        case 0x53: strncpy(keyName, "DELETE", maxLen); break;
        default: _snprintf(keyName, maxLen, "EXT_0x%02X", scanCode); break;
    }
}
```

```c
// 只处理按键按下事件，忽略释放事件
if (!(pInputData[i].Flags & KEY_BREAK)) {
    USHORT scanCode = pInputData[i].MakeCode;
    BOOLEAN isExtended = !!(pInputData[i].Flags & KEY_E0);
    
    if (isExtended) {
        // 处理扩展键
        CHAR keyName[32] = {0};
        ProcessExtendedKey(scanCode, keyName, sizeof(keyName));
        DbgPrint("[51asm] *** EXTENDED KEY PRESSED: %s ***\n", keyName);
    } else {
        // 处理普通按键
        CHAR keyChar = ScanCodeToChar(scanCode);
        if (keyChar != 0) {
            // 可打印字符
            DbgPrint("[51asm] *** KEY PRESSED: '%c' (ScanCode: 0x%02X) ***\n", 
                    keyChar, scanCode);
        } else {
            // 特殊按键
            CHAR keyName[32] = {0};
            GetSpecialKeyName(scanCode, keyName, sizeof(keyName));
            DbgPrint("[51asm] *** SPECIAL KEY PRESSED: %s ***\n", keyName);
        }
    }
} else {
    // 按键释放事件
    DbgPrint("[51asm] Key Released (ScanCode: 0x%02X)\n", pInputData[i].MakeCode);
}
```

能work

![](https://cdn.nlark.com/yuque/0/2025/png/49487941/1753604640072-490b89d9-5bab-483e-b94f-c1646398db0b.png)

## 检测hook
正常情况下设备栈应该是：应用 → KeyboardClass0 → USB/PS2

如果被Hook，变成：应用 → 过滤驱动 → KeyboardClass0 → USB/PS2

可以遍历设备栈



被Hook的IO派遣函数地址都不在自己的模块内部





参考资料

[https://bbs.kanxue.com/thread-278303.htm](https://bbs.kanxue.com/thread-278303.htm)

[https://bbs.kanxue.com/thread-264070.htm](https://bbs.kanxue.com/thread-264070.htm)

