写玩具的时候收集的信息，下文内容在win7 7601和win10 19h1经验证可行



加载不了驱动的cmd开测试签名

`bcdedit /set testsigning on    ` 

# 解析pdb
R3:[https://github.com/Kwansy98/EasyPdb](https://github.com/Kwansy98/EasyPdb/blob/main/ezpdb.hpp)

R0：[https://github.com/Oxygen1a1/oxgenPdb](https://github.com/Oxygen1a1/oxgenPdb)  他用的ksocket库只能发http请求，所以我只用他解析pdb,让R3调api下载。

也可以让ida下pdb 直接使用dia2dump解析即可

大家有什么在R0下载符号的方法吗

# GDT 全局描述符表解析

## 数据获取流程
用不了__asm了，用函数拿gdtr

```cpp
#include <immintrin.h>
extern "C" void _sgdt(void*);

GDTR gdtr = { 0 };
_sgdt(&gdtr);
```

我在R3拿居然是错的

**为什么R3获取的GDTR不准确？**
- Windows在用户态会虚拟化某些CPU状态，GDTR可能被重定向
- 内核态直接访问真实的CPU寄存器，数据更准确

## 数据流动思维链路

**步骤1：内存布局理解**
```
GDT基址 → [描述符0][描述符1][描述符2]...[TSS描述符][LDT描述符]
          ↓
每个描述符：32位=8字节，64位系统段=16字节
```

**步骤2：x64扩展机制**
在x64下，TSS（任务状态段）和LDT（局部描述符表）等系统段描述符扩展为16字节，占用连续两个GDT项。

前8字节与32位一样，后8字节用于补充TSS/LDT的高32位base地址和保留字段。

<u>所以解析数据的时候遇到s=0且type为TSS/LDT类型（type=2,9,11），和下一项8字节的数据合并一起解析。</u>

**步骤3：解析逻辑**
```
读取描述符 → 检查s位 → s=1(用户段) → 8字节解析
              ↓
             s=0(系统段) → 检查type → TSS/LDT? → 16字节解析
                          ↓                    ↓
                         其他系统段 → 8字节解析
```

**步骤4：平坦模式影响**
平坦模式导致数据段和代码段的base/limit字段失效，只需关注系统段的base/limit。

**为什么平坦模式下普通段的base/limit失效？**
- x64平坦内存模型：所有段的base=0, limit=0xFFFFFFFF
- 分页机制完全接管地址转换
- 只有系统段(TSS/LDT)保持传统分段机制

```cpp
typedef struct SegmentDescriptor32 {
    unsigned Limit1 : 16;    // 界限低16位
    unsigned Base1 : 16;     // 基址低16位
    unsigned Base2 : 8;      // 基址中8位
    unsigned type : 4;       // 段类型
    unsigned s : 1;          // 系统段标志
    unsigned dpl : 2;        // 特权级
    unsigned p : 1;          // 存在位

    unsigned Limit2 : 4;     // 界限高4位
    unsigned avl : 1;        // 软件可用位
    unsigned res : 1;        // 保留位
    unsigned db : 1;         // D/B位，0=16位段，1=32位段
    unsigned g : 1;          // 粒度位
    unsigned Base3 : 8;      // 基址高8位
} SegmentDescriptor32;
```

```cpp
typedef struct SegmentDescriptor {
    unsigned Limit1 : 16;    // 界限低16位
    unsigned Base1 : 16;     // 基址低16位  
    unsigned Base2 : 8;      // 基址中8位
    unsigned type : 4;       // 段类型
    unsigned s : 1;          // 系统段标志
    unsigned dpl : 2;        // 特权级
    unsigned p : 1;          // 存在位
    unsigned Limit2 : 4;     // 界限高4位
    unsigned avl : 1;        // 软件可用位
    unsigned l : 1;          // 64位代码段标志    以前的保留位
    unsigned db : 1;         // 操作数大小   	 以前代表段位数，64位代码段也就是l=1时db位必须为0
    unsigned g : 1;          // 粒度位
    unsigned Base3 : 8;      // 基址高8位
} SegmentDescriptor, *PSEGDESC;  // 确保是8字节

// 64位系统段描述符（16字节）
typedef struct SystemDescriptor64 {
    SegmentDescriptor low;   // 低8字节
    unsigned Base4 : 32;     // 基址最高32位
    unsigned reserved : 32;  // 保留字段
} SystemDescriptor64;
```



# SSDT 系统服务描述符表解析

## 32位与64位架构差异
在 64位Windows 中，SSDT表的结构与32位不同：

+ **32位**：SSDT表直接存储函数地址（直接指针）
+ **64位**：SSDT表存储的是相对偏移量（需要计算得到真实地址）

**为什么64位要用偏移量？**
- 64位地址空间巨大，直接存储8字节指针浪费空间
- 系统调用函数通常集中在内核镜像附近，偏移量足够
- 4字节偏移量比8字节指针节省50%空间

## 数据流动思维链路

**步骤1：获取SSDT基址**
```
KeServiceDescriptorTable → SSDT表基址
          ↓
     [偏移量0][偏移量1][偏移量2]...
```

**步骤2：偏移量解码过程**
```cpp
ULONG_PTR SSDT_GetPfnAddr(ULONG dwIndex, PULONG lpBase)
{
    ULONG_PTR lpAddr = NULL;
    ULONG dwOffset = lpBase[dwIndex];  // 读取压缩偏移量

    //按16位对齐省空间，所以>>4;负偏移有+-问题，所以|0xF00..
    if (dwOffset & 0x80000000)         // 检查符号位
        dwOffset = (dwOffset >> 4) | 0xF0000000;  // 负偏移符号扩展
    else
        dwOffset >>= 4;                // 正偏移直接右移

    lpAddr = (ULONG_PTR)((PUCHAR)lpBase + (LONG)dwOffset);
    return lpAddr;
}
```

**步骤3：数据转换详解**

1. **右移4位原理**：Windows x64中，SSDT偏移量以16字节对齐，所以低4位总是0，可以节省空间
   ```
   原始偏移: 0x12340 (已16字节对齐)
   压缩存储: 0x1234  (右移4位)
   解压缩:   0x12340 (左移4位)
   ```

2. **符号扩展处理**：处理负偏移（向前的地址），通过| 0xF0000000进行符号扩展
   ```
   负偏移标识: dwOffset & 0x80000000 != 0
   符号扩展:   (dwOffset >> 4) | 0xF0000000
   目的:      将28位有符号数扩展为32位有符号数
   ```

3. **相对地址计算**：最终地址 = SSDT基址 + 计算出的偏移量
   ```
   最终地址 = (PUCHAR)KeServiceDescriptorTable.Base + 解码后的偏移量
   ```

**步骤4：地址验证**
```
计算出的地址 → 检查是否在内核地址空间 → 检查是否可执行 → 返回函数指针
```

抄这篇[https://bbs.kanxue.com/thread-248117.htm](https://bbs.kanxue.com/thread-248117.htm)

# 遍历进程的三种方法对比

## 数据流动对比分析

### 方法1：进程链表遍历
**数据流向**：
```
PsInitialSystemProcess → EPROCESS.ActiveProcessLinks → 下一个EPROCESS → ...
```

**优点**：
- 直接访问内核数据结构，速度快
- 不依赖系统API，难以被用户态hook

**缺点**：
- 容易被Rootkit断链隐藏
- 需要硬编码偏移量，版本兼容性差
- 链表可能被破坏导致BSOD

**思维链路**：
```
1. 获取系统进程EPROCESS → 2. 遍历ActiveProcessLinks链表 → 3. 提取进程信息
```

### 方法2：PsLookupProcessByProcessId 
**数据流向**：
```
进程ID → 句柄表查找 → 返回EPROCESS指针
```

函数内部会查句柄表，相比链表更安全

![](https://cdn.nlark.com/yuque/0/2025/png/49487941/1754037901988-546e5456-e5f7-4ee2-8550-98b2d470746b.png)

**优点**：
- 官方API，稳定性好
- 自动处理引用计数，避免对象被释放
- 不容易导致系统崩溃

**缺点**：
- 需要预先知道PID
- 无法发现所有进程，只能验证指定进程
- 性能相对较差（需要遍历句柄表）

**思维链路**：
```
1. 提供PID → 2. 内核查找句柄表 → 3. 验证权限 → 4. 返回EPROCESS
```

### 方法3：内存特征搜索EPROCESS
**数据流向**：
```
内核内存池 → 按EPROCESS特征搜索 → 验证结构完整性 → 提取进程
```

有什么表敌我都知道 最后还得暴力搜内存

**优点**：
- 最难被隐藏，即使断链也能发现
- 能发现所有进程，包括隐藏进程
- 不依赖任何系统结构

**缺点**：
- 性能消耗巨大（全内存扫描）
- 误报率高，需要大量验证
- 实现复杂，容易造成系统不稳定

**思维链路**：
```
1. 定义EPROCESS特征 → 2. 扫描内核内存池 → 3. 匹配特征模式 → 4. 验证结构 → 5. 提取进程信息
```

## 实战建议
- **常规检测**：使用方法1（链表遍历）
- **进程验证**：使用方法2（API查找）  
- **Rootkit检测**：结合方法3（内存搜索）发现隐藏进程

# 遍历模块
[利用PsLoadModuleList 杖举驱动模块 - KTr - 博客园](https://www.cnblogs.com/ktr39/p/3494875.html)

或者 <font style="color:rgb(22, 22, 22);">ZwQueryInformation</font>

# 枚举回调机制的内核数据结构

[https://bbs.kanxue.com/thread-148895.htm](https://bbs.kanxue.com/thread-148895.htm)

## 回调存储机制对比

### 数组型回调（进程/线程/模块）
**存储结构**：**进程 线程 模块 **都用数组存放回调函数指针

**内核符号**：
- PspCreateProcessNotifyRoutine  （进程创建回调数组）
- PspCreateThreadNotifyRoutine   （线程创建回调数组）  
- PspLoadImageNotifyRoutine      （模块加载回调数组）

**数据结构**：
```cpp
typedef struct _EX_CALLBACK_ROUTINE_BLOCK {
    EX_RUNDOWN_REF        RundownProtect;   // Rundown protection structure
    PEX_CALLBACK_FUNCTION Function;         // 回调函数地址
    PVOID                 Context;          // 回调上下文参数
} EX_CALLBACK_ROUTINE_BLOCK, * PEX_CALLBACK_ROUTINE_BLOCK;
```

**数据流动**：
```
注册 → 在数组中找空位 → 填入EX_CALLBACK_ROUTINE_BLOCK结构
触发 → 遍历数组 → 调用所有非空回调函数
删除 → 通过索引/函数地址删除回调
```

**删除方式**：
```cpp
PsSetCreateProcessNotifyRoutine(functionAddr, TRUE);  // TRUE表示删除
```

**为什么用数组？**
- 进程/线程/模块事件频繁，数组遍历效率高
- 回调数量有限（通常64个以内），数组大小可控
- 支持按索引快速访问和删除



### 链表型回调（注册表/蓝屏/关机）
**存储结构**：**蓝屏 注册表 关机** 都用链表存放回调函数指针

#### 注册表回调
[https://cloud.tencent.com/developer/article/2366837](https://cloud.tencent.com/developer/article/2366837)

**数据结构**：
```cpp
//注册表回调结构 
typedef struct _CM_NOTIFY_ENTRY {
    LIST_ENTRY    ListEntryHead;        //链表项
    ULONG         UnKnown1;             
    ULONG         UnKnown2;             
    LARGE_INTEGER Cookie;               //回调标识符
    PVOID         Context;              //用户上下文
    PVOID         Function;             //回调函数地址
} CM_NOTIFY_ENTRY, *PCM_NOTIFY_ENTRY;
```

**数据流动**：
```
注册 → 分配CM_NOTIFY_ENTRY → 插入链表 → 生成Cookie返回
触发 → 遍历链表 → 调用所有回调函数  
删除 → 根据Cookie定位节点 → 从链表移除 → 释放内存
```

定位链表遍历就行

![](https://cdn.nlark.com/yuque/0/2025/png/49487941/1753621510106-d75aa48b-904e-4f6a-82f4-f2dd6c4448db.png)

**删除方式**：注册表回调得用cookie删除
```cpp
LARGE_INTEGER cookie;
cookie.QuadPart = (LONGLONG)deleteKey;  
NTSTATUS status = CmUnRegisterCallback(cookie);
```

**为什么用链表？**
- 注册表操作相对较少，对性能要求不高
- 回调数量不确定，链表动态扩展方便
- Cookie机制便于管理和删除特定回调



#### 蓝屏回调

结构体Wdm.h都有

**类型1：标准蓝屏回调 (KeBugCheckCallback)**
- **符号**: KeBugCheckCallbackListHead
- **结构**: KBUGCHECK_CALLBACK_RECORD  
- **用途**: 在蓝屏时保存数据、记录状态

```cpp
typedef struct _KBUGCHECK_CALLBACK_RECORD {
    LIST_ENTRY Entry;                        // 链表项
    PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine;  // 回调函数
    _Field_size_bytes_opt_(Length) PVOID Buffer;   // Buffer大小由Length字段指定
    ULONG Length;                            // 指定Buffer的字节长度
    PUCHAR Component;                        // 组件名
    ULONG_PTR Checksum;                     // 校验和
    UCHAR State;                            // 状态
} KBUGCHECK_CALLBACK_RECORD, *PKBUGCHECK_CALLBACK_RECORD;
```

**数据流动**：
```
注册 → 插入KeBugCheckCallbackListHead链表
蓝屏触发 → 遍历链表 → 调用所有回调保存数据
删除 → 通过结构指针从链表移除
```

**删除方式**：蓝屏回调通过 结构指针 删除
```cpp
KeDeregisterBugCheckCallback(recordPtr);
```

**类型2：蓝屏原因回调 (KeRegisterBugCheckReasonCallback)**
- **符号**: KeBugCheckReasonCallbackListHead
- **结构**: KBUGCHECK_REASON_CALLBACK_RECORD
- **用途**: 根据蓝屏原因执行特定处理

```cpp
typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
    LIST_ENTRY Entry;                           // 链表项
    PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine;  // 回调函数
    PUCHAR Component;                           // 组件名
    ULONG_PTR Checksum;                        // 校验和
    KBUGCHECK_CALLBACK_REASON Reason;          // 回调原因
    UCHAR State;                               // 状态
} KBUGCHECK_REASON_CALLBACK_RECORD, * PKBUGCHECK_REASON_CALLBACK_RECORD;
```

#### 关机回调

**符号**: IopNotifyShutdownQueueHead

```cpp
//关机回调结构
typedef struct _SHUTDOWN_PACKET {
    LIST_ENTRY ListEntry;               // +0x00 链表项
    PDEVICE_OBJECT DeviceObject;        // +0x10 设备对象
    PIRP Irp;                          // +0x18 IRP
} SHUTDOWN_PACKET, *PSHUTDOWN_PACKET;
```

**数据流动**：
```
注册 → IoRegisterShutdownNotification → 创建SHUTDOWN_PACKET → 插入IopNotifyShutdownQueueHead
关机触发 → 遍历链表 → 向每个设备发送IRP_MJ_SHUTDOWN
删除 → IoUnregisterShutdownNotification → 从链表移除SHUTDOWN_PACKET
```

## 回调机制设计思想总结

**数组 vs 链表选择原则**：
- **高频事件** (进程/线程/模块) → **数组**：遍历快，索引访问
- **低频事件** (注册表/蓝屏/关机) → **链表**：动态扩展，内存节省

**删除机制对比**：
- **数组回调**：通过函数地址匹配删除
- **注册表回调**：通过Cookie精确删除  
- **蓝屏回调**：通过结构指针删除
- **关机回调**：通过设备对象删除

# IO派遣函数/设备栈
```plain
3: kd> dt nt!_DRIVER_OBJECT -o
   Type             : Int2B
   Size             : Int2B
   DeviceObject     : Ptr64 _DEVICE_OBJECT
   Flags            : Uint4B
   DriverStart      : Ptr64 Void
   DriverSize       : Uint4B
   DriverSection    : Ptr64 Void
   DriverExtension  : Ptr64 _DRIVER_EXTENSION
   DriverName       : _UNICODE_STRING
   HardwareDatabase : Ptr64 _UNICODE_STRING
   FastIoDispatch   : Ptr64 _FAST_IO_DISPATCH
   DriverInit       : Ptr64     long 
   DriverStartIo    : Ptr64     void 
   DriverUnload     : Ptr64     void 
   MajorFunction    : [28] Ptr64     long 

```

遍历驱动对象方法： [https://bbs.kanxue.com/thread-276245.htm](https://bbs.kanxue.com/thread-276245.htm)

```plain
VOID EnumDriverObject(PDRIVER_OBJECT DriverObject) {
	PUCHAR DriverObjectByte = (PUCHAR)DriverObject;
	POBJECT_HEADER_NAME_INFO PObjHeaderNameInfo = DriverObjectByte - _OBJECT_HEADER_Body_Offset - sizeof(OBJECT_HEADER_NAME_INFO);
	POBJECT_DIRECTORY PDirectory = PObjHeaderNameInfo->Directory;//¸ÃÇý¶¯ËùÔÚÄ¿Â¼
	PDRIVER_OBJECT TargetDrvObj = NULL;
	POBJECT_DIRECTORY_ENTRY PSubDirectoryEntry = NULL;
	POBJECT_DIRECTORY_ENTRY PDirectoryEntry = NULL;
	//DbgBreakPoint();
	for (int i = 0; i < 37; i++) {
		PDirectoryEntry = PDirectory->HashBuckets[i];
		if (PDirectoryEntry == NULL) {
			continue;
		}
		PSubDirectoryEntry = PDirectoryEntry;
		while (PSubDirectoryEntry != NULL) {
			TargetDrvObj = PSubDirectoryEntry->Object;
			DbgPrint("DrvObj : %p  DrvName : %wZ  \n", TargetDrvObj, &TargetDrvObj->DriverName);
			PSubDirectoryEntry = PSubDirectoryEntry->ChainLink;
		}
	}

}
```

![](https://cdn.nlark.com/yuque/0/2025/png/49487941/1753709964153-77bb7848-c82d-4cae-9ef9-b50393b90395.png)

实测能跑

拿到驱动对象就可以拿设备对象 然后遍历attachdevice 和MajorFunction

查被过滤的设备   检测派遣函数指针是否在xx模块内

# 网络端口
R3有API 可以拿到端口pid

有示例代码

[getTcpTable 函数 (iphlpapi.h) - Win32 apps](https://learn.microsoft.com/zh-cn/windows/win32/api/iphlpapi/nf-iphlpapi-gettcptable)

[getExtendedTcpTable 函数 (iphlpapi.h) - Win32 apps](https://learn.microsoft.com/zh-cn/windows/win32/api/iphlpapi/nf-iphlpapi-getextendedtcptable)

R0 欸 不会啊



# 解除文件占用 - 内核对象流转过程

## 核心思想
强制关闭文件句柄 - 在目标进程上下文中调用 ZwClose() 关闭文件句柄

## 数据流动思维链路

**步骤1：句柄表遍历**
```
SystemExtendedHandleInformation → 全局句柄表 → 每个进程的句柄信息
```

**步骤2：对象类型过滤**  
```
句柄对象 → ObReferenceObjectByPointer → 验证是否为文件对象(IoFileObjectType)
```

**步骤3：文件路径匹配**
```
文件对象 → ObQueryNameString → 获取完整路径 → 字符串比较匹配目标文件
```

**步骤4：进程上下文切换**
```
PsLookupProcessByProcessId → 获取EPROCESS → KeStackAttachProcess → 切换到目标进程
```

**步骤5：句柄关闭**
```
目标进程上下文 → ZwClose(句柄值) → 减少引用计数 → 解除文件占用
```

**为什么要切换进程上下文？**
- Windows句柄表是进程私有的
- 在A进程上下文中无法操作B进程的句柄
- KeStackAttachProcess临时切换到目标进程的地址空间

```plain
NTSTATUS UnlockFile(WCHAR* filePath) {

    //遍历所有进程句柄表
    NTSTATUS Status;
    PSYSTEM_HANDLE_INFORMATION_EX      HandlesEx;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleInfoEx;
    POBJECT_NAME_INFORMATION  ObjectNameInfo;
    PVOID Buffer;
    ULONG BufferSize = 4096;
    ULONG ReturnLength;
    ULONG_PTR i;
    UNICODE_STRING ustrName;

    RtlInitUnicodeString(&ustrName, filePath);
    Log("[XM] UnlockFile ustr: %wZ", &ustrName);

    ObjectNameInfo = (POBJECT_NAME_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, 4096, 'ULFL');
    if (!ObjectNameInfo) {
        return STATUS_NO_MEMORY;
    }

retry:
    Buffer = ExAllocatePoolWithTag(NonPagedPool, BufferSize, 'ULFL');
    if (!Buffer) {
        ExFreePool(ObjectNameInfo);
        return STATUS_NO_MEMORY;
    }
    Status = ZwQuerySystemInformation(SystemExtendedHandleInformation,
        Buffer,
        BufferSize,
        &ReturnLength
    );

    if (Status == STATUS_INFO_LENGTH_MISMATCH) {
        ExFreePool(Buffer);
        BufferSize = ReturnLength;
        goto retry;
    }

    if (NT_SUCCESS(Status)) {

        HandlesEx = (PSYSTEM_HANDLE_INFORMATION_EX)Buffer;

        Log("[XM] 开始遍历句柄，总数: %llu", HandlesEx->NumberOfHandles);

        for (i = 0; i < HandlesEx->NumberOfHandles; i++) {
            HandleInfoEx = &(HandlesEx->Handles[i]);
            Status = ObReferenceObjectByPointer(HandleInfoEx->Object, 0,
                *IoFileObjectType, KernelMode);//*IoFileObjectType

            if (NT_SUCCESS(Status)) {
                Status = ObQueryNameString(HandleInfoEx->Object, ObjectNameInfo, 4096, &ReturnLength);

                if (NT_SUCCESS(Status)) {
                                      
                    if (RtlCompareUnicodeString(&ObjectNameInfo->Name, &ustrName, TRUE) == 0) {
                        Log("[XM] 找到匹配句柄: PID=%llu, Handle=%llu, Path=%wZ",
                            HandleInfoEx->UniqueProcessId,
                            HandleInfoEx->HandleValue,
                            &ObjectNameInfo->Name);

                        //切换进程
                        PEPROCESS Process = NULL;
                        Status = PsLookupProcessByProcessId((HANDLE)HandleInfoEx->UniqueProcessId, &Process);

                        if (NT_SUCCESS(Status)) {
                            KAPC_STATE ApcState;
                            KeStackAttachProcess(Process, &ApcState);
                            Status = ZwClose((HANDLE)HandleInfoEx->HandleValue);

                            Log("[XM] unlock UniqueProcessId:%llu HandleValue:%llu Name:%wZ",
                                HandleInfoEx->UniqueProcessId,
                                HandleInfoEx->HandleValue,
                                &ObjectNameInfo->Name);

                            KeUnstackDetachProcess(&ApcState);
                            ObDereferenceObject(Process);
                        }
                    }
                }
                ObDereferenceObject(HandleInfoEx->Object);
            }
        }

    }

    ExFreePool(ObjectNameInfo);
    ExFreePool(Buffer);
    return Status;
}
```

# 文件粉碎
先解锁后删除

ZwDeleteFile(&ustrName); 



# 路径转换 - Windows路径层次体系

## 三层路径转换体系

### 1. DOS路径 (用户层)
**示例**: `C:\Users\XiaM\Desktop\1.txt`
- **名称**: DOS路径 (DOS Path) / Win32路径
- **用途**: 用户和应用程序使用的标准路径
- **特点**: 使用盘符，对用户友好

### 2. NT路径 (内核接口层)  
**示例**: `\??\C:\Users\XiaM\Desktop\1.txt`
- **名称**: NT路径 (NT Path) / 符号链接路径  
- **用途**: NT内核的路径表示，?? 是符号链接目录
- **特点**: 内核API接受的标准格式

### 3. 设备路径 (设备层)
**示例**: `\Device\HarddiskVolume1\Users\XiaM\Desktop\1.txt`
- **名称**: 设备路径 (Device Path) / 物理设备路径  
- **用途**: 内核对象管理器中的真实设备路径
- **特点**: 直接对应物理设备，绕过所有符号链接

## 数据流动转换链路

```
DOS路径 → NT路径 → 设备路径
C:\...  → \??\C:\... → \Device\HarddiskVolume1\...
```

**转换过程**：
```
用户输入DOS路径 → QueryDosDevice查询符号链接 → 获取真实设备名 → 拼接完整设备路径
```

**为什么需要转换到设备路径？**
- 像UnlockFile功能需要在R3获取文件路径，转换为设备路径  
- 内核中的文件对象路径是设备路径格式
- 避免符号链接重定向影响

```cpp
// DOS路径到设备路径转换
std::wstring ConvertToDevicePath(const std::wstring& dosPath) {
    WCHAR driveLetter[3] = {dosPath[0], L':', L'\0'};
    WCHAR deviceName[MAX_PATH];    // 查询DOS设备对应的真实设备
    if (QueryDosDeviceW(driveLetter, deviceName, MAX_PATH)) {
        // 拼接：设备名 + 路径部分
        std::wstring result = deviceName;          // \Device\HarddiskVolume3
        result += dosPath.substr(2);               // + \Users\XiaM\Desktop\1.txt
        return result;
    }
    return L"";
}
```

**转换示例**：
```
QueryDosDevice("C:") → "\Device\HarddiskVolume3"
"C:\test.txt" → "\Device\HarddiskVolume3\test.txt"
```

# 强制关闭进程
<font style="color:rgb(0, 0, 0);">PspTerminateProcess</font>

<font style="color:rgb(0, 0, 0);">PspTerminateThreadByPointer</font>

[https://bbs.kanxue.com/thread-270012.htm](https://bbs.kanxue.com/thread-270012.htm)





后续原地补充

