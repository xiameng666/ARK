# Windows x64 内核开发信息快查

> 本文档基于 Windows 7 7601 和 Windows 10 19H1 验证，收集了内核开发中的常用技巧和代码片段。

## 环境配置

### 驱动测试签名
如果加载不了驱动，在管理员CMD中开启测试签名：
```cmd
bcdedit /set testsigning on
```

## 符号解析

### R3 符号解析
使用 [EasyPdb](https://github.com/Kwansy98/EasyPdb) 库进行用户态符号解析：

```cpp
#include "ezpdb.hpp"

// 初始化PDB解析器
ez::pdb pdb;
if (pdb.load("ntoskrnl.exe")) {
    // 获取函数地址
    auto funcAddr = pdb.getFunctionAddress("NtCreateFile");
}
```

### R0 符号解析
使用 [oxgenPdb](https://github.com/Oxygen1a1/oxgenPdb) 进行内核态符号解析：

```cpp
// 动态获取内核函数地址
typedef NTSTATUS (NTAPI *NtQuerySystemInformation_t)(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

NtQuerySystemInformation_t pfn = (NtQuerySystemInformation_t)ntos.GetPointer("NtQuerySystemInformation");
if (pfn) {
    // 调用函数
    NTSTATUS status = pfn(SystemHandleInformation, buffer, size, &returnLength);
}
```

## GDT (全局描述符表)

### 获取GDTR
在x64下无法使用内联汇编，需要使用intrinsic函数：

```cpp
#include <immintrin.h>

extern "C" void _sgdt(void*);

typedef struct _GDTR {
    USHORT Limit;
    ULONG64 Base;
} GDTR, *PGDTR;

GDTR gdtr = { 0 };
_sgdt(&gdtr);
```

### x64 GDT 结构差异

在x64下，TSS（任务状态段）和LDT（局部描述符表）等系统段描述符扩展为16字节，占用连续两个GDT项。

**32位段描述符结构：**
```cpp
typedef struct SegmentDescriptor32 {
    unsigned Limit1 : 16;    // 界限低16位
    unsigned Base1 : 16;     // 基址低16位
    unsigned Base2 : 8;      // 基址中8位
    unsigned type : 4;       // 段类型
    unsigned s : 1;          // 系统段标志
    unsigned dpl : 2;        // 特权级
    unsigned p : 1;          // 存在位
    unsigned Limit2 : 4;     // 界限高4位
    unsigned avl : 1;        // 软件可用位
    unsigned res : 1;        // 保留位
    unsigned db : 1;         // D/B位，0=16位段，1=32位段
    unsigned g : 1;          // 粒度位
    unsigned Base3 : 8;      // 基址高8位
} SegmentDescriptor32;
```

**64位段描述符结构：**
```cpp
typedef struct SegmentDescriptor {
    unsigned Limit1 : 16;    // 界限低16位
    unsigned Base1 : 16;     // 基址低16位  
    unsigned Base2 : 8;      // 基址中8位
    unsigned type : 4;       // 段类型
    unsigned s : 1;          // 系统段标志
    unsigned dpl : 2;        // 特权级
    unsigned p : 1;          // 存在位
    unsigned Limit2 : 4;     // 界限高4位
    unsigned avl : 1;        // 软件可用位
    unsigned l : 1;          // 64位代码段标志
    unsigned db : 1;         // 操作数大小，64位代码段l=1时db必须为0
    unsigned g : 1;          // 粒度位
    unsigned Base3 : 8;      // 基址高8位
} SegmentDescriptor, *PSEGDESC;

// 64位系统段描述符（16字节）
typedef struct SystemDescriptor64 {
    SegmentDescriptor low;   // 低8字节
    unsigned Base4 : 32;     // 基址最高32位
    unsigned reserved : 32;  // 保留字段
} SystemDescriptor64;
```

**注意：** 解析数据时遇到s=0且type为TSS/LDT类型（type=2,9,11），需要和下一项8字节数据合并一起解析。

平坦模式导致数据段和代码段的base/limit字段失效，只需关注系统段的base/limit。

## SSDT (系统服务描述符表)

在64位Windows中，SSDT表结构与32位不同：

- **32位：** SSDT表直接存储函数地址
- **64位：** SSDT表存储相对偏移量，需要计算得到真实地址

```cpp
ULONG_PTR SSDT_GetPfnAddr(ULONG dwIndex, PULONG lpBase)
{
    ULONG_PTR lpAddr = NULL;
    ULONG dwOffset = lpBase[dwIndex];

    // 按16位对齐省空间，所以>>4
    // 负偏移有符号问题，所以|0xF0000000
    if (dwOffset & 0x80000000)
        dwOffset = (dwOffset >> 4) | 0xF0000000;
    else
        dwOffset >>= 4;

    lpAddr = (ULONG_PTR)((PUCHAR)lpBase + (LONG)dwOffset);
    return lpAddr;
}
```

**计算原理：**
1. 右移4位：Windows x64中SSDT偏移量以16字节对齐，低4位总是0
2. 符号扩展：处理负偏移，通过|0xF0000000进行符号扩展
3. 相对地址计算：最终地址 = SSDT基址 + 计算出的偏移量

## 进程管理

### EPROCESS结构偏移量
项目使用动态偏移量适配不同Windows版本：

```cpp
typedef struct ENUM_PROCESS_META {
    ULONG EThreadToProcess;     // ETHREAD -> EPROCESS 偏移
    ULONG ProcessId;           // UniqueProcessId 偏移
    ULONG ActiveProcessLinks;  // ActiveProcessLinks 偏移
    ULONG ParentProcessId;     // InheritedFromUniqueProcessId 偏移
    ULONG ImageFileName;       // ImageFileName 偏移
    ULONG DirectoryTableBase;  // CR3页目录基地址偏移
} ENUM_PROCESS_META, *PENUM_PROCESS_OFFSETS;
```

### 进程枚举方法

**方法1：通过ActiveProcessLinks链表遍历**
```cpp
NTSTATUS EnumProcessFromLinksEx(PPROCESS_INFO processBuffer, 
                               BOOLEAN onlyGetCount, 
                               PULONG processCount) {
    // 从当前EPROCESS的ActiveProcessLinks开始遍历
    // 这种方法直接操作内核数据结构，速度快
    PEPROCESS currentProcess = PsGetCurrentProcess();
    PLIST_ENTRY processListHead = (PLIST_ENTRY)((PUCHAR)currentProcess + offsets.ActiveProcessLinks);
    
    // 遍历双向链表获取所有进程
    // 详见 NTDriver/process.cpp 实现
}
```

**方法2：通过PsLookupProcessByProcessId API**
```cpp  
NTSTATUS EnumProcessByApiEx(PPROCESS_INFO ProcessInfos, 
                           BOOLEAN bCountOnly, 
                           PULONG pCount) {
    // 枚举PID范围，调用PsLookupProcessByProcessId验证
    // 这种方法相对安全，但效率较低
    for (ULONG pid = 4; pid < 65536; pid += 4) {
        PEPROCESS process = NULL;
        if (NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)pid, &process))) {
            // 提取进程信息
            ObDereferenceObject(process);
        }
    }
}
```

### 强制终止进程

**方法1：调用PspTerminateProcess**
```cpp
NTSTATUS TerminateProcessByApi(HANDLE ProcessId) {
    PEPROCESS Process;
    NTSTATUS status = PsLookupProcessByProcessId(ProcessId, &Process);
    if (NT_SUCCESS(status)) {
        // 直接调用内核未导出函数
        typedef NTSTATUS (*PspTerminateProcess_t)(PEPROCESS Process);
        PspTerminateProcess_t pfnTerminate = 
            (PspTerminateProcess_t)ntos.GetPointer("PspTerminateProcess");
        
        if (pfnTerminate) {
            status = pfnTerminate(Process);
        }
        ObDereferenceObject(Process);
    }
    return status;
}
```

**方法2：终止所有线程**
```cpp
NTSTATUS TerminateProcessByThread(HANDLE ProcessId) {
    // 枚举目标进程的所有线程
    // 逐个调用PspTerminateThreadByPointer强制终止
    // 当所有线程都被终止后，进程自然死亡
    // 详见 NTDriver/process.cpp:TerminateProcessByThread 实现
}
```

## 回调枚举

### 进程/线程/模块回调
这些回调都用数组存放回调函数指针：

```cpp
// 回调结构体
typedef struct _EX_CALLBACK_ROUTINE_BLOCK {
    EX_RUNDOWN_REF        RundownProtect;   // Rundown保护结构
    PEX_CALLBACK_FUNCTION Function;         // 回调函数地址
    PVOID                 Context;          // 回调上下文参数
} EX_CALLBACK_ROUTINE_BLOCK, *PEX_CALLBACK_ROUTINE_BLOCK;

// 删除回调
NTSTATUS RemoveProcessCallback(PEX_CALLBACK_FUNCTION functionAddr) {
    return PsSetCreateProcessNotifyRoutine(functionAddr, TRUE);
}
```

### 注册表回调
注册表回调使用链表存放：

```cpp
typedef struct _CM_NOTIFY_ENTRY {
    LIST_ENTRY    ListEntryHead;        // 链表项
    ULONG         UnKnown1;             
    ULONG         UnKnown2;             
    LARGE_INTEGER Cookie;               // 回调标识符
    PVOID         Context;              // 用户上下文
    PVOID         Function;             // 回调函数地址
} CM_NOTIFY_ENTRY, *PCM_NOTIFY_ENTRY;

// 删除注册表回调
NTSTATUS RemoveRegistryCallback(LARGE_INTEGER cookie) {
    return CmUnRegisterCallback(cookie);
}
```

### 蓝屏回调

**标准蓝屏回调：**
```cpp
typedef struct _KBUGCHECK_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine;
    PVOID Buffer;                        // Buffer大小由Length字段指定
    ULONG Length;                        // 指定Buffer的字节长度
    PUCHAR Component;
    ULONG_PTR Checksum;
    UCHAR State;
} KBUGCHECK_CALLBACK_RECORD, *PKBUGCHECK_CALLBACK_RECORD;

// 删除蓝屏回调
NTSTATUS RemoveBugCheckCallback(PKBUGCHECK_CALLBACK_RECORD recordPtr) {
    return KeDeregisterBugCheckCallback(recordPtr);
}
```

**蓝屏原因回调：**
```cpp
typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
    LIST_ENTRY Entry;                           // 链表项
    PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine;  // 回调函数
    PUCHAR Component;                           // 组件名
    ULONG_PTR Checksum;                        // 校验和
    KBUGCHECK_CALLBACK_REASON Reason;          // 回调原因
    UCHAR State;                               // 状态
} KBUGCHECK_REASON_CALLBACK_RECORD, *PKBUGCHECK_REASON_CALLBACK_RECORD;
```

### 关机回调
```cpp
typedef struct _SHUTDOWN_PACKET {
    LIST_ENTRY ListEntry;               // +0x00 链表项
    PDEVICE_OBJECT DeviceObject;        // +0x10 设备对象
    PIRP Irp;                          // +0x18 IRP
} SHUTDOWN_PACKET, *PSHUTDOWN_PACKET;
```

## 驱动对象遍历

### DRIVER_OBJECT 结构
```cpp
typedef struct _DRIVER_OBJECT {
    USHORT Type;                    // +0x00
    USHORT Size;                    // +0x02
    PVOID DeviceObject;             // +0x08
    ULONG Flags;                    // +0x10
    PVOID DriverStart;              // +0x18
    ULONG DriverSize;               // +0x20
    PVOID DriverSection;            // +0x28
    PVOID DriverExtension;          // +0x30
    UNICODE_STRING DriverName;      // +0x38
    UNICODE_STRING HardwareDatabase; // +0x48
    PVOID FastIoDispatch;           // +0x58
    PVOID DriverInit;               // +0x60
    PVOID DriverStartIo;            // +0x68
    PVOID DriverUnload;             // +0x70
    PVOID MajorFunction[28];        // +0x78
} DRIVER_OBJECT, *PDRIVER_OBJECT;
```

### 遍历驱动对象
```cpp
VOID EnumDriverObject(PDRIVER_OBJECT DriverObject) {
    PUCHAR DriverObjectByte = (PUCHAR)DriverObject;
    POBJECT_HEADER_NAME_INFO PObjHeaderNameInfo = 
        DriverObjectByte - _OBJECT_HEADER_Body_Offset - sizeof(OBJECT_HEADER_NAME_INFO);
    POBJECT_DIRECTORY PDirectory = PObjHeaderNameInfo->Directory;
    
    PDRIVER_OBJECT TargetDrvObj = NULL;
    POBJECT_DIRECTORY_ENTRY PSubDirectoryEntry = NULL;
    POBJECT_DIRECTORY_ENTRY PDirectoryEntry = NULL;
    
    for (int i = 0; i < 37; i++) {
        PDirectoryEntry = PDirectory->HashBuckets[i];
        if (PDirectoryEntry == NULL) {
            continue;
        }
        
        PSubDirectoryEntry = PDirectoryEntry;
        while (PSubDirectoryEntry != NULL) {
            TargetDrvObj = PSubDirectoryEntry->Object;
            DbgPrint("DrvObj: %p  DrvName: %wZ\n", 
                     TargetDrvObj, &TargetDrvObj->DriverName);
            PSubDirectoryEntry = PSubDirectoryEntry->ChainLink;
        }
    }
}
```

拿到驱动对象后可以获取设备对象，然后遍历attachdevice和MajorFunction。

## 网络端口

### R3 端口枚举
```cpp
#include <iphlpapi.h>
#pragma comment(lib, "iphlpapi.lib")

NTSTATUS EnumTcpConnections() {
    ULONG size = 0;
    GetExtendedTcpTable(NULL, &size, TRUE, AF_INET, 
                        TCP_TABLE_OWNER_PID_ALL, 0);
    
    PMIB_TCPTABLE_OWNER_PID tcpTable = (PMIB_TCPTABLE_OWNER_PID)malloc(size);
    if (GetExtendedTcpTable(tcpTable, &size, TRUE, AF_INET, 
                           TCP_TABLE_OWNER_PID_ALL, 0) == NO_ERROR) {
        for (DWORD i = 0; i < tcpTable->dwNumEntries; i++) {
            DbgPrint("PID: %d, Local: %d, Remote: %d\n",
                     tcpTable->table[i].dwOwningPid,
                     ntohs(tcpTable->table[i].dwLocalPort),
                     ntohs(tcpTable->table[i].dwRemotePort));
        }
    }
    free(tcpTable);
    return STATUS_SUCCESS;
}
```

## 文件操作

### 强制关闭文件句柄
在目标进程上下文中调用ZwClose()关闭文件句柄：

```cpp
NTSTATUS ForceCloseFileHandle(HANDLE ProcessId, HANDLE HandleValue) {
    PEPROCESS Process;
    NTSTATUS status = PsLookupProcessByProcessId(ProcessId, &Process);
    if (NT_SUCCESS(status)) {
        KAPC_STATE ApcState;
        KeStackAttachProcess(Process, &ApcState);
        
        // 在目标进程上下文中操作
        status = ZwClose(HandleValue);
        
        KeUnstackDetachProcess(&ApcState);
        ObDereferenceObject(Process);
    }
    return status;
}
```

### 文件粉碎
先解锁后删除：

```cpp
NTSTATUS ShredFile(UNICODE_STRING* filePath) {
    // 先强制关闭所有句柄
    ForceCloseAllFileHandles(filePath);
    
    // 然后删除文件
    return ZwDeleteFile(filePath);
}
```

## 路径格式

Windows中有三种主要的路径格式：

### 1. DOS路径 (Win32路径)
```
C:\Users\XiaM\Desktop\1.txt
```
- **用途：** 用户和应用程序使用的标准路径
- **特点：** 最常用的路径格式

### 2. NT路径 (符号链接路径)
```
\??\C:\Users\XiaM\Desktop\1.txt
```
- **用途：** NT内核的路径表示
- **特点：** `\??` 是符号链接目录

### 3. 设备路径 (物理设备路径)
```
\Device\HarddiskVolume1\Users\XiaM\Desktop\1.txt
```
- **用途：** 内核对象管理器中的真实设备路径
- **特点：** 内核态操作使用的路径格式

### 路径转换关系
```
DOS路径 → NT路径 → 设备路径
C:\...  → \??\C:\... → \Device\HarddiskVolume1\...
```

### 路径转换代码示例
```cpp
// DOS路径转NT路径
NTSTATUS DosPathToNtPath(PWCHAR dosPath, PUNICODE_STRING ntPath) {
    typedef NTSTATUS (NTAPI *RtlDosPathNameToNtPathName_U_t)(
        PWCHAR DosFileName,
        PUNICODE_STRING NtFileName,
        PWCHAR* FilePart,
        PVOID RelativeName
    );
    
    RtlDosPathNameToNtPathName_U_t pfn = 
        (RtlDosPathNameToNtPathName_U_t)ntos.GetPointer("RtlDosPathNameToNtPathName_U");
    
    if (pfn) {
        return pfn(dosPath, ntPath, NULL, NULL);
    }
    return STATUS_UNSUCCESSFUL;
}

// NT路径转设备路径
NTSTATUS NtPathToDevicePath(PWCHAR ntPath, PWCHAR devicePath, ULONG maxLen) {
    // 简单转换示例：\??\C:\ → \Device\HarddiskVolume1\
    if (wcsncmp(ntPath, L"\\??\\", 4) == 0) {
        swprintf_s(devicePath, maxLen, L"\\Device\\HarddiskVolume1%s", ntPath + 4);
        return STATUS_SUCCESS;
    }
    return STATUS_UNSUCCESSFUL;
}
```

## 句柄枚举

### 系统句柄信息结构
```cpp
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    ULONG ProcessId;
    BYTE ObjectTypeNumber;
    BYTE Flags;
    USHORT Handle;
    PVOID Object;
    ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;
```

### 枚举文件句柄
```cpp
NTSTATUS EnumFileHandles(PWCHAR targetPath) {
    PSYSTEM_HANDLE_INFORMATION handleInfo = NULL;
    ULONG size = 0;
    NTSTATUS status;
    
    // 获取句柄信息
    status = NtQuerySystemInformation(SystemHandleInformation, NULL, 0, &size);
    if (status != STATUS_INFO_LENGTH_MISMATCH) {
        return status;
    }
    
    handleInfo = (PSYSTEM_HANDLE_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, size, 'Hndl');
    if (!handleInfo) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    status = NtQuerySystemInformation(SystemHandleInformation, handleInfo, size, NULL);
    if (NT_SUCCESS(status)) {
        for (ULONG i = 0; i < handleInfo->NumberOfHandles; i++) {
            PSYSTEM_HANDLE_TABLE_ENTRY_INFO handle = &handleInfo->Handles[i];
            
            // 获取对象名称信息
            POBJECT_NAME_INFORMATION nameInfo = NULL;
            ULONG nameSize = 0;
            
            status = ObQueryNameString(handle->Object, NULL, 0, &nameSize);
            if (status == STATUS_INFO_LENGTH_MISMATCH) {
                nameInfo = (POBJECT_NAME_INFORMATION)ExAllocatePoolWithTag(
                    NonPagedPool, nameSize, 'Name');
                if (nameInfo) {
                    status = ObQueryNameString(handle->Object, nameInfo, nameSize, NULL);
                    if (NT_SUCCESS(status)) {
                        // 比较路径
                        if (RtlCompareUnicodeString(&nameInfo->Name, 
                                                   targetPath, TRUE) == 0) {
                            DbgPrint("找到目标文件句柄: PID=%d, Handle=%d\n",
                                     handle->ProcessId, handle->Handle);
                        }
                    }
                    ExFreePool(nameInfo);
                }
            }
        }
    }
    
    ExFreePool(handleInfo);
    return status;
}
```

## 常用内核函数

### 进程相关
```cpp
// 查找进程
NTSTATUS PsLookupProcessByProcessId(HANDLE ProcessId, PEPROCESS* Process);

// 附加到进程
VOID KeStackAttachProcess(PEPROCESS Process, PKAPC_STATE ApcState);
VOID KeUnstackDetachProcess(PKAPC_STATE ApcState);

// 引用计数
VOID ObDereferenceObject(PVOID Object);
```

### 文件操作
```cpp
// 创建文件
NTSTATUS ZwCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess,
                      POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock,
                      PLARGE_INTEGER AllocationSize, ULONG FileAttributes,
                      ULONG ShareAccess, ULONG CreateDisposition,
                      ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);

// 删除文件
NTSTATUS ZwDeleteFile(POBJECT_ATTRIBUTES ObjectAttributes);

// 关闭句柄
NTSTATUS ZwClose(HANDLE Handle);
```

### 内存管理
```cpp
// 分配内存
PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);

// 释放内存
VOID ExFreePool(PVOID P);
```

### 字符串操作
```cpp
// 初始化Unicode字符串
VOID RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);

// 比较Unicode字符串
LONG RtlCompareUnicodeString(PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive);

// 路径转换
NTSTATUS RtlDosPathNameToNtPathName_U(PWCHAR DosFileName, PUNICODE_STRING NtFileName,
                                       PWCHAR* FilePart, PVOID RelativeName);
```

## 调试技巧

### 内核调试输出
```cpp
// 使用DbgPrint输出调试信息
DbgPrint("[DEBUG] 变量值: %d\n", variable);

// 使用Log函数（自定义）
Log("[INFO] 操作成功: %s\n", operation);
```

### 断点调试
```cpp
// 软件断点
DbgBreakPoint();

// 条件断点
if (condition) {
    DbgBreakPoint();
}
```

### 内存检查
```cpp
// 检查指针有效性
if (MmIsAddressValid(pointer)) {
    // 安全访问内存
}
```

## 错误处理

### 常见NTSTATUS值
```cpp
#define STATUS_SUCCESS                    ((NTSTATUS)0x00000000L)
#define STATUS_UNSUCCESSFUL              ((NTSTATUS)0xC0000001L)
#define STATUS_INVALID_HANDLE            ((NTSTATUS)0xC0000008L)
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)
#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)
#define STATUS_OBJECT_NAME_NOT_FOUND     ((NTSTATUS)0xC0000034L)
#define STATUS_ACCESS_DENIED             ((NTSTATUS)0xC0000022L)
```

### 错误检查宏
```cpp
// 检查NTSTATUS是否成功
if (NT_SUCCESS(status)) {
    // 操作成功
} else {
    // 处理错误
    DbgPrint("操作失败: 0x%08X\n", status);
}
```

---

> 本文档持续更新中，如有错误或遗漏，欢迎指正。

